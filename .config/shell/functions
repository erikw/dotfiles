# Utility shell functions.
# vi: foldmarker={,} filetype=sh foldmethod=marker foldlevel=0: tabstop=4 shiftwidth=4:

# Dynamically source functions from the drop-in directory. {
if [ -d ${XDG_CONFIG_HOME:-$HOME/.config}/shell/functions.d ]; then
	for funcfile in ${XDG_CONFIG_HOME:-$HOME/.config}/shell/functions.d/*.sh; do
		source $funcfile
	done;
fi

# }

# Check if we have a program in PATH
program_is_in_path() {
	local program="$1"
	type "$1" >/dev/null 2>&1
}

# Shell detect functions {
	export SHELL_PLATFORM=unknown
	#ostype() { echo $OSTYPE | tr '[:upper:]' '[:lower:]'; }
	ostype() { echo $OSTYPE; } # tr is not built-in => expensive. See if this works in practive, to not lowercase.
	case "$(ostype)" in
		*'linux'*	) SHELL_PLATFORM=linux	;;
		*'darwin'*	) SHELL_PLATFORM=macos	;;
		*'freebsd'*	) SHELL_PLATFORM=freebsd	;;
		*'bsd'*		) SHELL_PLATFORM=bsd		;;
		*'msys'*	) SHELL_PLATFORM=windows	;;
	esac

	shell_is_linux() { [ "$SHELL_PLATFORM" = linux ]; }
	shell_is_macos() { [ "$SHELL_PLATFORM" = macos ]; }
	shell_is_freebsd() { [ "$SHELL_PLATFORM" = freebsd ]; }
	shell_is_bsd() { [ "$SHELL_PLATFORM" = bsd ] || [ "$SHELL_PLATFORM" = freebsd ] || [ "$SHELL_PLATFORM" = macos ]; }
	shell_is_windows() { [ "$SHELL_PLATFORM" = windows ]; }

	# Test if the shell is interactive.
	shell_is_interactive() {
		#tty -s >/dev/null 2>/dev/null
		case $- in
			*i*) return 0;;
			*) return 1;;
		esac
	}
# }

# ps-grep
# List matching processes. Wrap in function instead of alias to avoid bug when searching for name that is also binary found in PATH
psg() {
	ps aux | grep "$*"
}

# cd to the directory containing the program found in PATH.
cdw() {
	local prog="$1"
	if type "$prog" >/dev/null 2>&1; then
		dir=$(dirname $(which "$prog"))
		echo "$dir"
		cd "$dir"
	else
		echo "\"${prog}\" not found in \$PATH." >&2
	fi
}
export cdw >/dev/null
[ -n "$completion_func" ] && shell_is_interactive && $completion_func -cf cdw

# Time conversions.
epoch2iso8601() {
	local epoch="$1"
	local len=$(echo -n $epoch | wc -m)
	# Assume that a longer string means we have ms or ns - simply strip down to seconds.
	if [ $len -gt 10 ]; then
		epoch=$(echo $epoch | cut -c 1-10)
	fi
	date -d @$epoch +%Y-%m-%dT%H:%M:%S%z
}
export epoch2iso8601 >/dev/null

iso86012epoch() {
	local iso="$1"
	date -d "$iso" +%s
}
export iso86012epoch >/dev/null

# Stopwatch, press enter to time.
# Source: http://superuser.com/questions/611538/is-there-a-way-to-display-a-countdown-or-stopwatch-timer-in-a-terminal
stopwatch() {
	date1=$(date +%s);
	while :; do
		days=$(( $(($(date +%s) - date1)) / 86400 ))
		echo -ne "$days day(s) and $(date -u --date @$(($(date +%s) - $date1)) +%H:%M:%S)\r";
		sleep 0.1
	done
}

# Visual countdown with voice announcing that the time is up.
#termdownsay() {
	#termdown -b -q 1 $@ && espeak -v en -s 130 -a 120 "Time has ended"
#}

# Git overlay which adds a command to cd to the root of a git repo.
git() {
	# TODO whereis find /usr/bin/git from Xcode and not /usr/local/bin git from brew
	# -q: macOS, supress name prefix. Replaced with cut(1); not avilable on GNU/Linux it seems.
	# -b: macOS, only search binary not manual
	local gitbin=$( whereis -b git | cut -d ' ' -f 2)

	if [ "$1" = root ]; then
		# Try get root from git submodule:
		local root="$($gitbin rev-parse --show-superproject-working-tree)"
		# Else we're in the main repo already:
		# --show-cdup will not take us to the root if we came here from a symlink.
		#test -n "$root" || root="$($gitbin rev-parse --show-cdup)"
		# Instead get full path with --show-to-level https://stackoverflow.com/q/39746533/265508
		test -n "$root" || root="$($gitbin rev-parse --show-toplevel)"
		[ -n "$root" ] && cd "$root"
	else
		$gitbin $@
	fi
}

# Wrapper around the classic 'vi with ack' with search highlighting.
# Usage example: viack -i "search_term
# Last argument is the search string. Preceding arguments are for ack.
viack() {
	local search
	# Get the last argument. Reference: https://stackoverflow.com/a/1853993/265508
	for search; do true; done
	vi -p $(ack -l $@) -c 1 +/$search  # Go to first line then search downwards.
}

# Wrapper around the classic 'vi with grep'.
vigrep() {
	local search
	for search; do true; done
	vi -p $(grep -Rl $@) -c 1 +/$search
}

# Wrapper around the classic 'rg with grep'.
virg() {
	local search
	for search; do true; done
	vi -p $(rg -l $@) -c 1 +/$search
}

# Wrapper around the classic 'fd with grep'.
vifd() {
	vi -p $(fd $@)
}

_dev_log() {
	local message="$@"
	echo "ðŸ”¨ > $message..."
}

# Encrypt file with a symmetric cipher.
encryptf() {
	local file="$1"
	local filecrypt="$1.gpg"
	[ -z "$file" ] && echo "No filename given!" >&2 && return
	if ! [ -e "$file" ]; then
		echo "File '$file' does not exist!" >&2
		return
	fi
	gpg --symmetric --output "$filecrypt"  "$file" >/dev/null
	[ "$?" -ne 0 ] && echo "Encryption failed!" >&2 && return
	rm "$file"
	printf "Encrypted %s to %s\n" "$file" "$filecrypt"
	# Clear gpg-agent password cache
	echo RELOADAGENT | gpg-connect-agent >/dev/null
}

# Decrypt file with a symmetric cipher.
decryptf() {
	local filecrypt="$1"
	local file=${filecrypt%.gpg}
	[ -z "$filecrypt" ] && echo "No filename given!" >&2 && return
	if ! [ -e "$filecrypt" ]; then
		echo "File '$filecrypt' does not exist!" >&2
		return
	fi
	gpg --decrypt --output "$file"  "$filecrypt" 2>/dev/null
	[ "$?" -ne 0 ] && echo "Decryption failed!" >&2 && return
	rm "$filecrypt"
	printf "Decrypted %s to %s\n" "$filecrypt" "$file"
}

# cd in to newly created directory.
function mkdircd() {
	local dir="$1"
	mkdir -p "$dir"
	cd "$dir"
}
alias mkcd=mkdircd

# cd in to newly created directory.
function mkdirtodaycd() {
	# BSD date don't have the -I switch like GNU date.
	local today=$(date +%Y-%m-%d)
	mkdircd "$today"
}

# Connect ssh and start tmux e.g.
# $ sshmux <host>
# Reference: https://stackoverflow.com/a/27614878/265508
sshmux () {
	local args="$@"
	ssh -t $args "tmux attach || tmux new-session"
}

# Connect mosh and start tmux.
moshmux () {
	local args="$@"
	mosh $args -- sh -c "tmux attach || tmux new-session"
}

# cd(1) to installation of gem from bundle.
bundlecd() {
	local gem="$@"
	local path=$(bundle info --path "$gem")
	test $? -eq 0 && cd "$path"
}

# Swap two file's names. Reference: https://stackoverflow.com/a/1119738/265508
swap() {
    local TMPFILE=tmp.$$
    mv "$1" $TMPFILE
    mv "$2" "$1"
    mv $TMPFILE "$2"
}

# Sleep random time within an interval.
# Reference: https://serverfault.com/questions/347582/adding-a-random-delay-for-a-linux-command
sleep_random() {
	max_sleep_sec="$1"
	#perl -e "sleep int(rand(${max_sleep_sec}))"
	sleep $((RANDOM % $max_sleep_sec))
}

# Sleep specified time and then shut down
# Usage: sleep_shutdown 3h
sleep_shutdown() {
	time="$1"
	if program_is_in_path gsleep; then
		gsleep $time && shutdown -h now
	else
		sleep $time && shutdown -h now
	fi
}

# Search Dash.app.
# Note, can't use name 'dash' as this is the dash shell.
# Usage: dashs "term"
dashs() {
	local term="$*"
	open "dash://${term}"
}
